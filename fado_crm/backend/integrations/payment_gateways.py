# FADO CRM - Payment Gateway Integrations # Tich hop cac cong thanh toan pho bien tai Viet Nam from abc import ABC, abstractmethod from typing import Dict, List, Optional, Any from datetime import datetime, timedelta import json import hashlib import hmac import base64 import uuid from enum import Enum import asyncio import aiohttp from sqlalchemy.orm import Session # Payment status enums class PaymentStatus(Enum): PENDING = "pending" PROCESSING = "processing" SUCCESS = "success" FAILED = "failed" CANCELLED = "cancelled" REFUNDED = "refunded" PARTIAL_REFUND = "partial_refund" class PaymentMethod(Enum): VNPAY = "vnpay" MOMO = "momo" ZALOPAY = "zalopay" VIETQR = "vietqr" BANK_TRANSFER = "bank_transfer" CASH = "cash" CREDIT_CARD = "credit_card" class Currency(Enum): VND = "VND" USD = "USD" # Abstract Payment Gateway Interface class PaymentGateway(ABC): """ Abstract base class for payment gateway integrations """ def __init__(self, config: Dict[str, Any]): self.config = config self.name = self.__class__.__name__ self.is_sandbox = config.get('sandbox', True) @abstractmethod async def create_payment(self, payment_data: Dict[str, Any]) -> Dict[str, Any]: """Tao payment request""" pass @abstractmethod async def verify_payment(self, transaction_id: str, verification_data: Dict[str, Any]) -> Dict[str, Any]: """Xac minh payment tu callback""" pass @abstractmethod async def get_payment_status(self, transaction_id: str) -> Dict[str, Any]: """Lay trang thai payment""" pass @abstractmethod async def refund_payment(self, transaction_id: str, refund_amount: float, reason: str = "") -> Dict[str, Any]: """Hoan tien""" pass def generate_transaction_id(self) -> str: """Tao transaction ID unique""" return f"FADO_{int(datetime.now().timestamp())}_{uuid.uuid4().hex[:8].upper()}" # VNPay Gateway Implementation class VNPayGateway(PaymentGateway): """ VNPay payment gateway integration Cong thanh toan pho bien nhat tai Viet Nam """ def __init__(self, config: Dict[str, Any]): super().__init__(config) self.merchant_id = config.get('merchant_id', '') self.secret_key = config.get('secret_key', '') self.api_url = config.get('api_url', 'https://sandbox.vnpayment.vn/paymentv2/vpcpay.html') self.return_url = config.get('return_url', '') self.notify_url = config.get('notify_url', '') async def create_payment(self, payment_data: Dict[str, Any]) -> Dict[str, Any]: """ Tao VNPay payment request """ try: order_id = payment_data.get('order_id', self.generate_transaction_id()) amount = int(payment_data.get('amount', 0) * 100) # VNPay requires amount in cents order_info = payment_data.get('description', f'Thanh toan don hang {order_id}') customer_info = payment_data.get('customer', {}) # Build VNPay parameters vnp_params = { 'vnp_Version': '2.1.0', 'vnp_Command': 'pay', 'vnp_TmnCode': self.merchant_id, 'vnp_Amount': str(amount), 'vnp_CurrCode': 'VND', 'vnp_TxnRef': order_id, 'vnp_OrderInfo': order_info, 'vnp_OrderType': 'other', 'vnp_Locale': 'vn', 'vnp_ReturnUrl': self.return_url, 'vnp_IpAddr': payment_data.get('ip_address', '127.0.0.1'), 'vnp_CreateDate': datetime.now().strftime('%Y%m%d%H%M%S'), 'vnp_ExpireDate': (datetime.now() + timedelta(minutes=30)).strftime('%Y%m%d%H%M%S') } # Add customer info if available if customer_info.get('email'): vnp_params['vnp_Bill_Email'] = customer_info['email'] if customer_info.get('phone'): vnp_params['vnp_Bill_Mobile'] = customer_info['phone'] if customer_info.get('name'): vnp_params['vnp_Bill_FirstName'] = customer_info['name'] # Generate secure hash query_string = self._build_query_string(vnp_params) secure_hash = self._generate_secure_hash(query_string) vnp_params['vnp_SecureHash'] = secure_hash # Build payment URL payment_url = f"{self.api_url}?{self._build_query_string(vnp_params)}" return { 'success': True, 'transaction_id': order_id, 'payment_url': payment_url, 'gateway': 'vnpay', 'expires_at': vnp_params['vnp_ExpireDate'], 'amount': amount / 100, 'currency': 'VND' } except Exception as e: return { 'success': False, 'error': str(e), 'gateway': 'vnpay' } async def verify_payment(self, transaction_id: str, verification_data: Dict[str, Any]) -> Dict[str, Any]: """ Xac minh VNPay payment callback """ try: # Extract VNPay response parameters vnp_params = {} secure_hash = verification_data.get('vnp_SecureHash', '') for key, value in verification_data.items(): if key.startswith('vnp_') and key != 'vnp_SecureHash': vnp_params[key] = value # Verify secure hash query_string = self._build_query_string(vnp_params) expected_hash = self._generate_secure_hash(query_string) if secure_hash != expected_hash: return { 'success': False, 'error': 'Invalid secure hash', 'status': PaymentStatus.FAILED.value } # Check transaction status response_code = verification_data.get('vnp_ResponseCode', '99') transaction_status = verification_data.get('vnp_TransactionStatus', '02') if response_code == '00' and transaction_status == '00': status = PaymentStatus.SUCCESS else: status = PaymentStatus.FAILED return { 'success': True, 'transaction_id': verification_data.get('vnp_TxnRef'), 'gateway_transaction_id': verification_data.get('vnp_TransactionNo'), 'status': status.value, 'amount': float(verification_data.get('vnp_Amount', 0)) / 100, 'currency': 'VND', 'payment_date': verification_data.get('vnp_PayDate'), 'bank_code': verification_data.get('vnp_BankCode', ''), 'card_type': verification_data.get('vnp_CardType', ''), 'gateway': 'vnpay' } except Exception as e: return { 'success': False, 'error': str(e), 'status': PaymentStatus.FAILED.value, 'gateway': 'vnpay' } async def get_payment_status(self, transaction_id: str) -> Dict[str, Any]: """ Query VNPay payment status """ try: query_params = { 'vnp_Version': '2.1.0', 'vnp_Command': 'querydr', 'vnp_TmnCode': self.merchant_id, 'vnp_TxnRef': transaction_id, 'vnp_OrderInfo': f'Query transaction {transaction_id}', 'vnp_TransactionDate': datetime.now().strftime('%Y%m%d%H%M%S'), 'vnp_CreateDate': datetime.now().strftime('%Y%m%d%H%M%S'), 'vnp_IpAddr': '127.0.0.1' } # Generate secure hash for query query_string = self._build_query_string(query_params) secure_hash = self._generate_secure_hash(query_string) query_params['vnp_SecureHash'] = secure_hash # Make API call to VNPay query_url = self.config.get('query_api_url', 'https://sandbox.vnpayment.vn/merchant_webapi/api/transaction') async with aiohttp.ClientSession() as session: async with session.post(query_url, data=query_params) as response: result = await response.json() if result.get('vnp_ResponseCode') == '00': status = PaymentStatus.SUCCESS if result.get('vnp_TransactionStatus') == '00' else PaymentStatus.FAILED return { 'success': True, 'transaction_id': transaction_id, 'status': status.value, 'amount': float(result.get('vnp_Amount', 0)) / 100, 'gateway': 'vnpay' } else: return { 'success': False, 'error': f"VNPay error: {result.get('vnp_ResponseCode')}", 'status': PaymentStatus.FAILED.value, 'gateway': 'vnpay' } except Exception as e: return { 'success': False, 'error': str(e), 'gateway': 'vnpay' } async def refund_payment(self, transaction_id: str, refund_amount: float, reason: str = "") -> Dict[str, Any]: """ VNPay refund implementation (requires manual process) """ try: # VNPay refunds typically require manual processing # This creates a refund request that needs to be processed through VNPay merchant portal refund_data = { 'transaction_id': transaction_id, 'refund_amount': refund_amount, 'reason': reason or 'Customer request', 'refund_date': datetime.now().isoformat(), 'status': 'pending_manual_processing', 'note': 'VNPay refunds require manual processing through merchant portal' } return { 'success': True, 'refund_id': f"RF_{transaction_id}_{int(datetime.now().timestamp())}", 'status': 'pending_manual_processing', 'refund_data': refund_data, 'gateway': 'vnpay' } except Exception as e: return { 'success': False, 'error': str(e), 'gateway': 'vnpay' } def _build_query_string(self, params: Dict[str, str]) -> str: """Build sorted query string for VNPay""" sorted_params = sorted(params.items()) query_parts = [f"{key}={value}" for key, value in sorted_params if value] return '&'.join(query_parts) def _generate_secure_hash(self, query_string: str) -> str: """Generate VNPay secure hash""" return hmac.new( self.secret_key.encode('utf-8'), query_string.encode('utf-8'), hashlib.sha512 ).hexdigest() # MoMo Gateway Implementation class MoMoGateway(PaymentGateway): """ MoMo e-wallet payment gateway Vi dien tu pho bien tai Viet Nam """ def __init__(self, config: Dict[str, Any]): super().__init__(config) self.partner_code = config.get('partner_code', '') self.access_key = config.get('access_key', '') self.secret_key = config.get('secret_key', '') self.api_url = config.get('api_url', 'https://test-payment.momo.vn/v2/gateway/api/create') self.return_url = config.get('return_url', '') self.notify_url = config.get('notify_url', '') async def create_payment(self, payment_data: Dict[str, Any]) -> Dict[str, Any]: """ Tao MoMo payment request """ try: order_id = payment_data.get('order_id', self.generate_transaction_id()) amount = int(payment_data.get('amount', 0)) order_info = payment_data.get('description', f'Thanh toan don hang {order_id}') request_id = f"{order_id}_{int(datetime.now().timestamp())}" # MoMo request parameters raw_data = { 'partnerCode': self.partner_code, 'partnerName': 'FADO CRM', 'storeId': 'FADO_STORE', 'requestId': request_id, 'amount': amount, 'orderId': order_id, 'orderInfo': order_info, 'redirectUrl': self.return_url, 'ipnUrl': self.notify_url, 'lang': 'vi', 'extraData': '', 'requestType': 'payWithATM', 'signature': '' } # Generate signature raw_signature = ( f"accessKey={self.access_key}&" f"amount={amount}&" f"extraData=&" f"ipnUrl={self.notify_url}&" f"orderId={order_id}&" f"orderInfo={order_info}&" f"partnerCode={self.partner_code}&" f"redirectUrl={self.return_url}&" f"requestId={request_id}&" f"requestType=payWithATM" ) signature = hmac.new( self.secret_key.encode('utf-8'), raw_signature.encode('utf-8'), hashlib.sha256 ).hexdigest() raw_data['signature'] = signature # Make API call to MoMo async with aiohttp.ClientSession() as session: async with session.post(self.api_url, json=raw_data) as response: result = await response.json() if result.get('resultCode') == 0: return { 'success': True, 'transaction_id': order_id, 'payment_url': result.get('payUrl'), 'gateway': 'momo', 'amount': amount, 'currency': 'VND', 'deep_link': result.get('deeplink'), # For mobile app integration 'qr_code': result.get('qrCodeUrl') # QR code for scanning } else: return { 'success': False, 'error': f"MoMo error: {result.get('message', 'Unknown error')}", 'error_code': result.get('resultCode'), 'gateway': 'momo' } except Exception as e: return { 'success': False, 'error': str(e), 'gateway': 'momo' } async def verify_payment(self, transaction_id: str, verification_data: Dict[str, Any]) -> Dict[str, Any]: """ Xac minh MoMo payment callback """ try: # Verify MoMo signature signature = verification_data.get('signature', '') # Build raw signature data raw_signature = ( f"accessKey={self.access_key}&" f"amount={verification_data.get('amount', '')}&" f"extraData={verification_data.get('extraData', '')}&" f"message={verification_data.get('message', '')}&" f"orderId={verification_data.get('orderId', '')}&" f"orderInfo={verification_data.get('orderInfo', '')}&" f"orderType={verification_data.get('orderType', '')}&" f"partnerCode={verification_data.get('partnerCode', '')}&" f"payType={verification_data.get('payType', '')}&" f"requestId={verification_data.get('requestId', '')}&" f"responseTime={verification_data.get('responseTime', '')}&" f"resultCode={verification_data.get('resultCode', '')}&" f"transId={verification_data.get('transId', '')}" ) expected_signature = hmac.new( self.secret_key.encode('utf-8'), raw_signature.encode('utf-8'), hashlib.sha256 ).hexdigest() if signature != expected_signature: return { 'success': False, 'error': 'Invalid signature', 'status': PaymentStatus.FAILED.value, 'gateway': 'momo' } # Check payment status result_code = int(verification_data.get('resultCode', 99)) status = PaymentStatus.SUCCESS if result_code == 0 else PaymentStatus.FAILED return { 'success': True, 'transaction_id': verification_data.get('orderId'), 'gateway_transaction_id': verification_data.get('transId'), 'status': status.value, 'amount': float(verification_data.get('amount', 0)), 'currency': 'VND', 'payment_date': verification_data.get('responseTime'), 'pay_type': verification_data.get('payType', ''), 'gateway': 'momo' } except Exception as e: return { 'success': False, 'error': str(e), 'status': PaymentStatus.FAILED.value, 'gateway': 'momo' } async def get_payment_status(self, transaction_id: str) -> Dict[str, Any]: """ Query MoMo payment status """ try: request_id = f"query_{transaction_id}_{int(datetime.now().timestamp())}" raw_data = { 'partnerCode': self.partner_code, 'requestId': request_id, 'orderId': transaction_id, 'lang': 'vi', 'signature': '' } # Generate signature for query raw_signature = ( f"accessKey={self.access_key}&" f"orderId={transaction_id}&" f"partnerCode={self.partner_code}&" f"requestId={request_id}" ) signature = hmac.new( self.secret_key.encode('utf-8'), raw_signature.encode('utf-8'), hashlib.sha256 ).hexdigest() raw_data['signature'] = signature query_url = self.config.get('query_api_url', 'https://test-payment.momo.vn/v2/gateway/api/query') async with aiohttp.ClientSession() as session: async with session.post(query_url, json=raw_data) as response: result = await response.json() if result.get('resultCode') == 0: status = PaymentStatus.SUCCESS elif result.get('resultCode') == 9000: status = PaymentStatus.PENDING else: status = PaymentStatus.FAILED return { 'success': True, 'transaction_id': transaction_id, 'status': status.value, 'amount': float(result.get('amount', 0)), 'gateway': 'momo' } except Exception as e: return { 'success': False, 'error': str(e), 'gateway': 'momo' } async def refund_payment(self, transaction_id: str, refund_amount: float, reason: str = "") -> Dict[str, Any]: """ MoMo refund implementation """ try: request_id = f"refund_{transaction_id}_{int(datetime.now().timestamp())}" trans_id = verification_data.get('transId', '') # Need original MoMo transaction ID refund_data = { 'partnerCode': self.partner_code, 'orderId': transaction_id, 'requestId': request_id, 'amount': int(refund_amount), 'transId': trans_id, 'lang': 'vi', 'description': reason or 'Refund request', 'signature': '' } # Generate signature raw_signature = ( f"accessKey={self.access_key}&" f"amount={int(refund_amount)}&" f"description={refund_data['description']}&" f"orderId={transaction_id}&" f"partnerCode={self.partner_code}&" f"requestId={request_id}&" f"transId={trans_id}" ) signature = hmac.new( self.secret_key.encode('utf-8'), raw_signature.encode('utf-8'), hashlib.sha256 ).hexdigest() refund_data['signature'] = signature refund_url = self.config.get('refund_api_url', 'https://test-payment.momo.vn/v2/gateway/api/refund') async with aiohttp.ClientSession() as session: async with session.post(refund_url, json=refund_data) as response: result = await response.json() if result.get('resultCode') == 0: return { 'success': True, 'refund_id': result.get('refundTrans'), 'status': 'success', 'refund_amount': refund_amount, 'gateway': 'momo' } else: return { 'success': False, 'error': f"MoMo refund error: {result.get('message')}", 'error_code': result.get('resultCode'), 'gateway': 'momo' } except Exception as e: return { 'success': False, 'error': str(e), 'gateway': 'momo' } # ZaloPay Gateway Implementation class ZaloPayGateway(PaymentGateway): """ ZaloPay e-wallet payment gateway """ def __init__(self, config: Dict[str, Any]): super().__init__(config) self.app_id = config.get('app_id', '') self.key1 = config.get('key1', '') self.key2 = config.get('key2', '') self.api_url = config.get('api_url', 'https://sb-openapi.zalopay.vn/v2/create') self.callback_url = config.get('callback_url', '') async def create_payment(self, payment_data: Dict[str, Any]) -> Dict[str, Any]: """ Tao ZaloPay payment request """ try: order_id = payment_data.get('order_id', self.generate_transaction_id()) amount = int(payment_data.get('amount', 0)) description = payment_data.get('description', f'Thanh toan don hang {order_id}') # ZaloPay order data order_data = { 'app_id': self.app_id, 'app_trans_id': f"{datetime.now().strftime('%y%m%d')}_{order_id}", 'app_user': payment_data.get('customer', {}).get('email', 'user'), 'app_time': int(datetime.now().timestamp() * 1000), 'item': json.dumps([{ 'name': description, 'quantity': 1, 'price': amount }]), 'embed_data': json.dumps({}), 'amount': amount, 'description': description, 'bank_code': '', 'callback_url': self.callback_url, } # Generate MAC signature mac_data = ( f"{order_data['app_id']}|{order_data['app_trans_id']}|{order_data['app_user']}|" f"{order_data['amount']}|{order_data['app_time']}|{order_data['embed_data']}|{order_data['item']}" ) order_data['mac'] = hmac.new( self.key1.encode('utf-8'), mac_data.encode('utf-8'), hashlib.sha256 ).hexdigest() # Make API call to ZaloPay async with aiohttp.ClientSession() as session: async with session.post(self.api_url, data=order_data) as response: result = await response.json() if result.get('return_code') == 1: return { 'success': True, 'transaction_id': order_id, 'app_trans_id': order_data['app_trans_id'], 'payment_url': result.get('order_url'), 'zp_trans_token': result.get('zp_trans_token'), 'gateway': 'zalopay', 'amount': amount, 'currency': 'VND' } else: return { 'success': False, 'error': f"ZaloPay error: {result.get('return_message', 'Unknown error')}", 'error_code': result.get('return_code'), 'gateway': 'zalopay' } except Exception as e: return { 'success': False, 'error': str(e), 'gateway': 'zalopay' } async def verify_payment(self, transaction_id: str, verification_data: Dict[str, Any]) -> Dict[str, Any]: """ Xac minh ZaloPay payment callback """ try: mac = verification_data.get('mac', '') data = verification_data.get('data', '{}') # Verify MAC expected_mac = hmac.new( self.key2.encode('utf-8'), data.encode('utf-8'), hashlib.sha256 ).hexdigest() if mac != expected_mac: return { 'success': False, 'error': 'Invalid MAC', 'status': PaymentStatus.FAILED.value, 'gateway': 'zalopay' } # Parse callback data callback_data = json.loads(data) return { 'success': True, 'transaction_id': callback_data.get('app_trans_id', '').split('_', 1)[-1], 'app_trans_id': callback_data.get('app_trans_id'), 'gateway_transaction_id': callback_data.get('zp_trans_id'), 'status': PaymentStatus.SUCCESS.value, 'amount': float(callback_data.get('amount', 0)), 'currency': 'VND', 'gateway': 'zalopay' } except Exception as e: return { 'success': False, 'error': str(e), 'status': PaymentStatus.FAILED.value, 'gateway': 'zalopay' } async def get_payment_status(self, transaction_id: str) -> Dict[str, Any]: """ Query ZaloPay payment status """ try: app_trans_id = f"{datetime.now().strftime('%y%m%d')}_{transaction_id}" query_data = { 'app_id': self.app_id, 'app_trans_id': app_trans_id } # Generate MAC for query mac_data = f"{query_data['app_id']}|{query_data['app_trans_id']}|{self.key1}" query_data['mac'] = hmac.new( self.key1.encode('utf-8'), mac_data.encode('utf-8'), hashlib.sha256 ).hexdigest() query_url = self.config.get('query_api_url', 'https://sb-openapi.zalopay.vn/v2/query') async with aiohttp.ClientSession() as session: async with session.post(query_url, data=query_data) as response: result = await response.json() if result.get('return_code') == 1: status = PaymentStatus.SUCCESS elif result.get('return_code') == 2: status = PaymentStatus.PROCESSING else: status = PaymentStatus.FAILED return { 'success': True, 'transaction_id': transaction_id, 'app_trans_id': app_trans_id, 'status': status.value, 'amount': float(result.get('amount', 0)), 'gateway': 'zalopay' } except Exception as e: return { 'success': False, 'error': str(e), 'gateway': 'zalopay' } async def refund_payment(self, transaction_id: str, refund_amount: float, reason: str = "") -> Dict[str, Any]: """ ZaloPay refund implementation """ try: # ZaloPay refunds require the original zp_trans_id from successful payment # This would typically be stored in the payment record zp_trans_id = verification_data.get('zp_trans_id', '') timestamp = int(datetime.now().timestamp() * 1000) refund_data = { 'app_id': self.app_id, 'zp_trans_id': zp_trans_id, 'amount': int(refund_amount), 'timestamp': timestamp, 'description': reason or 'Refund request' } # Generate MAC for refund mac_data = f"{refund_data['app_id']}|{refund_data['zp_trans_id']}|{refund_data['amount']}|{refund_data['description']}|{refund_data['timestamp']}" refund_data['mac'] = hmac.new( self.key1.encode('utf-8'), mac_data.encode('utf-8'), hashlib.sha256 ).hexdigest() refund_url = self.config.get('refund_api_url', 'https://sb-openapi.zalopay.vn/v2/refund') async with aiohttp.ClientSession() as session: async with session.post(refund_url, data=refund_data) as response: result = await response.json() if result.get('return_code') == 1: return { 'success': True, 'refund_id': result.get('refund_id'), 'status': 'success', 'refund_amount': refund_amount, 'gateway': 'zalopay' } else: return { 'success': False, 'error': f"ZaloPay refund error: {result.get('return_message')}", 'error_code': result.get('return_code'), 'gateway': 'zalopay' } except Exception as e: return { 'success': False, 'error': str(e), 'gateway': 'zalopay' } # Payment Gateway Manager class PaymentGatewayManager: """ Manager class de handle multiple payment gateways """ def __init__(self): self.gateways: Dict[str, PaymentGateway] = {} self.default_gateway = None def register_gateway(self, name: str, gateway: PaymentGateway, is_default: bool = False): """Dang ky payment gateway""" self.gateways[name] = gateway if is_default or not self.default_gateway: self.default_gateway = name def get_gateway(self, name: str = None) -> Optional[PaymentGateway]: """Lay gateway instance""" gateway_name = name or self.default_gateway return self.gateways.get(gateway_name) def get_available_gateways(self) -> List[str]: """Lay danh sach gateways available""" return list(self.gateways.keys()) async def create_payment(self, gateway_name: str, payment_data: Dict[str, Any]) -> Dict[str, Any]: """Tao payment qua gateway chi dinh""" gateway = self.get_gateway(gateway_name) if not gateway: return {'success': False, 'error': f'Gateway {gateway_name} not found'} return await gateway.create_payment(payment_data) async def verify_payment(self, gateway_name: str, transaction_id: str, verification_data: Dict[str, Any]) -> Dict[str, Any]: """Verify payment qua gateway""" gateway = self.get_gateway(gateway_name) if not gateway: return {'success': False, 'error': f'Gateway {gateway_name} not found'} return await gateway.verify_payment(transaction_id, verification_data) async def get_payment_status(self, gateway_name: str, transaction_id: str) -> Dict[str, Any]: """Lay status payment""" gateway = self.get_gateway(gateway_name) if not gateway: return {'success': False, 'error': f'Gateway {gateway_name} not found'} return await gateway.get_payment_status(transaction_id) async def refund_payment(self, gateway_name: str, transaction_id: str, refund_amount: float, reason: str = "") -> Dict[str, Any]: """Refund payment""" gateway = self.get_gateway(gateway_name) if not gateway: return {'success': False, 'error': f'Gateway {gateway_name} not found'} return await gateway.refund_payment(transaction_id, refund_amount, reason) # Factory function def create_payment_gateway_manager(config: Dict[str, Any]) -> PaymentGatewayManager: """ Factory function de tao PaymentGatewayManager voi config """ manager = PaymentGatewayManager() # Initialize VNPay if config.get('vnpay', {}).get('enabled', False): vnpay = VNPayGateway(config['vnpay']) manager.register_gateway('vnpay', vnpay, is_default=True) # Initialize MoMo if config.get('momo', {}).get('enabled', False): momo = MoMoGateway(config['momo']) manager.register_gateway('momo', momo) # Initialize ZaloPay if config.get('zalopay', {}).get('enabled', False): zalopay = ZaloPayGateway(config['zalopay']) manager.register_gateway('zalopay', zalopay) return manager