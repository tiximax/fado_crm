# FADO CRM - Error Handling Integration Tests # Testing comprehensive error handling va logging system import pytest from fastapi import status class TestErrorHandling: """ Error handling integration tests""" async def test_custom_exception_format(self, async_client, db_session): """Test custom exception response format""" response = await async_client.get("/san-pham/99999") assert response.status_code == status.HTTP_404_NOT_FOUND data = response.json() # Check custom error format assert "error" in data assert data["error"] is True assert "error_code" in data assert data["error_code"] == "NOT_FOUND" assert "message" in data assert "timestamp" in data assert "details" in data async def test_validation_error_format(self, async_client, db_session): """Test validation error response format""" # Send invalid product data invalid_data = {"ten_san_pham": "Test", "gia_goc": -10} # Negative price response = await async_client.post("/san-pham/", json=invalid_data) assert response.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY data = response.json() # Check validation error format assert "error" in data assert data["error"] is True assert "error_code" in data assert "validation_errors" in data.get("details", {}) async def test_request_id_tracking(self, async_client, db_session): """Test request ID is included in error responses""" response = await async_client.get("/san-pham/99999") # Check for X-Request-ID header assert "X-Request-ID" in response.headers request_id = response.headers["X-Request-ID"] assert len(request_id) == 8 # Short UUID format # Error response should include request ID context data = response.json() assert "timestamp" in data async def test_database_error_handling(self, async_client, sample_customer, db_session): """Test database error handling""" # Force a database constraint violation # Try to create customer with duplicate email customer_data = { "ho_ten": "Test Customer", "email": sample_customer.email, # Duplicate email "so_dien_thoai": "1234567890" } response = await async_client.post("/khach-hang/", json=customer_data) assert response.status_code == status.HTTP_400_BAD_REQUEST data = response.json() assert "Email nay da duoc su dung" in data["detail"] async def test_middleware_security_headers(self, async_client, db_session): """Test security headers are added by middleware""" response = await async_client.get("/") # Check security headers expected_headers = [ "X-Content-Type-Options", "X-Frame-Options", "X-XSS-Protection", "Referrer-Policy", "Content-Security-Policy" ] for header in expected_headers: assert header in response.headers async def test_concurrent_request_handling(self, async_client, db_session): """Test concurrent request handling with error tracking""" import asyncio # Create multiple concurrent requests that will fail async def make_failing_request(product_id): return await async_client.get(f"/san-pham/{product_id}") # Make concurrent requests to non-existent products tasks = [make_failing_request(99990 + i) for i in range(5)] responses = await asyncio.gather(*tasks) # All should fail with proper error format for response in responses: assert response.status_code == status.HTTP_404_NOT_FOUND data = response.json() assert data["error"] is True assert "X-Request-ID" in response.headers async def test_error_consistency(self, async_client, db_session): """Test error response consistency across endpoints""" # Test 404 errors across different endpoints endpoints_404 = [ "/khach-hang/99999", "/san-pham/99999", "/don-hang/99999" ] for endpoint in endpoints_404: response = await async_client.get(endpoint) assert response.status_code == status.HTTP_404_NOT_FOUND data = response.json() # All should follow same error format assert data["error"] is True assert data["error_code"] == "NOT_FOUND" assert "message" in data assert "timestamp" in data class TestLoggingSystem: """ Logging system tests""" async def test_api_call_logging(self, async_client, db_session): """Test API calls are logged properly""" # Make a successful request response = await async_client.get("/") assert response.status_code == status.HTTP_200_OK # Logging is handled by middleware, check for request ID assert "X-Request-ID" in response.headers async def test_error_logging(self, async_client, db_session): """Test errors are logged with context""" # Make a request that will fail response = await async_client.get("/san-pham/99999") assert response.status_code == status.HTTP_404_NOT_FOUND # Should have request ID for log correlation assert "X-Request-ID" in response.headers async def test_user_action_logging(self, async_client, db_session, sample_product_data): """Test user actions are logged""" # Create a product (should log user action) response = await async_client.post("/san-pham/", json=sample_product_data) assert response.status_code == status.HTTP_200_OK # Get product details (should log view action) product_id = response.json()["id"] response = await async_client.get(f"/san-pham/{product_id}") assert response.status_code == status.HTTP_200_OK async def test_business_event_logging(self, async_client, db_session, sample_product_data): """Test business events are logged""" # Create product (should log PRODUCT_CREATED event) response = await async_client.post("/san-pham/", json=sample_product_data) assert response.status_code == status.HTTP_200_OK # Delete product (should log PRODUCT_DELETED event) product_id = response.json()["id"] response = await async_client.delete(f"/san-pham/{product_id}") assert response.status_code == status.HTTP_200_OK class TestRobustness: """ System robustness tests""" async def test_malformed_json_handling(self, async_client, db_session): """Test handling of malformed JSON requests""" # Send malformed JSON response = await async_client.post( "/san-pham/", content='{"ten_san_pham": "Test", invalid_json', # Malformed headers={"Content-Type": "application/json"} ) # Should handle gracefully assert response.status_code in [400, 422] # Bad request or validation error async def test_large_payload_handling(self, async_client, db_session): """Test handling of unusually large payloads""" # Create product with very long description large_data = { "ten_san_pham": "Test Product", "gia_goc": 100.0, "gia_ban": 200000.0, "mo_ta": "x" * 10000, # Very long description "danh_muc": "Test" } response = await async_client.post("/san-pham/", json=large_data) # Should either accept or reject gracefully assert response.status_code in [200, 422, 413] # Success, validation error, or payload too large async def test_special_characters_handling(self, async_client, db_session): """Test handling of special characters and unicode""" special_data = { "ten_san_pham": "San pham dac biet ", "gia_goc": 100.0, "gia_ban": 200000.0, "mo_ta": "Mo ta voi ky tu dac biet: @#$%^&*()[]{}", "danh_muc": "Danh muc tieng Viet" } response = await async_client.post("/san-pham/", json=special_data) assert response.status_code == status.HTTP_200_OK # Retrieve and verify data integrity product_id = response.json()["id"] get_response = await async_client.get(f"/san-pham/{product_id}") assert get_response.status_code == status.HTTP_200_OK data = get_response.json() assert data["ten_san_pham"] == special_data["ten_san_pham"] async def test_rate_limiting_behavior(self, async_client, db_session): """Test system behavior under rapid requests""" import asyncio # Make rapid concurrent requests async def make_request(): return await async_client.get("/") # Create many concurrent requests tasks = [make_request() for _ in range(20)] responses = await asyncio.gather(*tasks, return_exceptions=True) # System should handle all requests gracefully success_count = sum(1 for r in responses if hasattr(r, 'status_code') and r.status_code == 200) assert success_count >= 15 # At least 75% should succeed # Error handling va robustness tests hoan thanh!
