# FADO CRM - Phase 6 Features Comprehensive Test Suite # Testing: ML Engine, PWA features, External integrations, Advanced security import pytest import asyncio import json from unittest.mock import Mock, AsyncMock, patch, MagicMock from datetime import datetime, timedelta import numpy as np import pandas as pd # Import Phase 6 modules from ml_engine import AdvancedMLEngine from integrations.payment_gateways import VNPayGateway, MoMoGateway, PaymentGatewayManager, PaymentStatus from integrations.shipping_apis import GHTKShippingAPI, GHNShippingAPI, ShippingAPIManager from security.advanced_security import ( AdvancedSecurityManager, RateLimiter, SecurityHeaders, InputValidator, SecurityAuditLogger, VulnerabilityScanner, SecurityThreatLevel, SecurityEventType, SecurityAction ) @pytest.fixture def mock_db_session(): """Mock database session""" session = Mock() session.query.return_value.filter.return_value.group_by.return_value.all.return_value = [] session.query.return_value.join.return_value.filter.return_value.group_by.return_value.all.return_value = [] session.query.return_value.outerjoin.return_value.filter.return_value.group_by.return_value.all.return_value = [] return session class TestAdvancedMLEngine: """ Test suite for ML Engine capabilities """ @pytest.fixture def ml_engine(self): return AdvancedMLEngine() def test_ml_engine_initialization(self, ml_engine): """Test ML engine initializes correctly""" assert ml_engine is not None assert hasattr(ml_engine, 'models_trained') assert hasattr(ml_engine, 'feature_scalers') assert hasattr(ml_engine, 'ml_available') @pytest.mark.asyncio async def test_get_time_series_data_no_ml_deps(self, ml_engine, mock_db_session): """Test time series data collection when ML dependencies unavailable""" ml_engine.ml_available = False result = await ml_engine.get_time_series_data(mock_db_session, days_back=30) assert result['available'] is False assert 'error' in result assert result['error'] == "ML dependencies not available" @pytest.mark.asyncio async def test_get_time_series_data_with_mock_data(self, ml_engine, mock_db_session): """Test time series data collection with mock data""" if not ml_engine.ml_available: pytest.skip("ML dependencies not available") # Mock database query results mock_daily_sales = [ Mock(date=datetime.now().date(), order_count=10, total_revenue=1000000, avg_order_value=100000), Mock(date=(datetime.now() - timedelta(days=1)).date(), order_count=8, total_revenue=800000, avg_order_value=100000) ] mock_db_session.query.return_value.filter.return_value.group_by.return_value.all.return_value = mock_daily_sales result = await ml_engine.get_time_series_data(mock_db_session, days_back=30) assert result['available'] is True assert 'daily_sales' in result assert len(result['daily_sales']) > 0 @pytest.mark.asyncio async def test_forecast_demand_insufficient_data(self, ml_engine, mock_db_session): """Test demand forecasting with insufficient data""" if not ml_engine.ml_available: pytest.skip("ML dependencies not available") # Mock empty data mock_db_session.query.return_value.filter.return_value.group_by.return_value.all.return_value = [] with patch.object(ml_engine, 'get_time_series_data') as mock_get_data: mock_get_data.return_value = {'available': True, 'daily_sales': []} result = await ml_engine.forecast_demand(mock_db_session, forecast_days=7) assert result.get('error') is not None assert 'Insufficient historical data' in result['error'] @pytest.mark.asyncio async def test_forecast_demand_with_data(self, ml_engine, mock_db_session): """Test demand forecasting with sufficient data""" if not ml_engine.ml_available: pytest.skip("ML dependencies not available") # Generate mock time series data dates = [datetime.now() - timedelta(days=i) for i in range(60, 0, -1)] mock_sales_data = [ { 'date': date.strftime('%Y-%m-%d'), 'order_count': 10 + (i % 7) * 2, # Weekly pattern 'total_revenue': (10 + (i % 7) * 2) * 100000, 'avg_order_value': 100000 } for i, date in enumerate(dates) ] with patch.object(ml_engine, 'get_time_series_data') as mock_get_data: mock_get_data.return_value = { 'available': True, 'daily_sales': mock_sales_data, 'category_trends': [], 'customer_trends': [] } result = await ml_engine.forecast_demand(mock_db_session, forecast_days=7) if result.get('available'): assert 'predictions' in result assert len(result['predictions']) == 7 assert 'seasonal_patterns' in result assert 'model_performance' in result @pytest.mark.asyncio async def test_anomaly_detection_no_data(self, ml_engine, mock_db_session): """Test anomaly detection with no data""" if not ml_engine.ml_available: pytest.skip("ML dependencies not available") # Mock empty transaction data mock_db_session.query.return_value.join.return_value.outerjoin.return_value.filter.return_value.group_by.return_value.all.return_value = [] result = await ml_engine.detect_anomalies(mock_db_session, analysis_days=30) assert result.get('error') is not None assert 'Insufficient transaction data' in result['error'] @pytest.mark.asyncio async def test_anomaly_detection_with_data(self, ml_engine, mock_db_session): """Test anomaly detection with transaction data""" if not ml_engine.ml_available: pytest.skip("ML dependencies not available") # Create mock transaction data base_time = datetime.now() mock_transactions = [] for i in range(50): mock_transaction = Mock() mock_transaction.id = i mock_transaction.ma_don_hang = f"ORDER_{i:04d}" mock_transaction.khach_hang_id = i % 10 # 10 customers mock_transaction.tong_tien = 1000000 if i != 45 else 10000000 # One anomaly mock_transaction.ngay_tao = base_time - timedelta(days=i) mock_transaction.trang_thai = Mock() mock_transaction.trang_thai.value = "completed" mock_transaction.customer_name = f"Customer {i % 10}" mock_transaction.email = f"customer{i % 10}@test.com" mock_transaction.so_dien_thoai = f"090000000{i % 10}" mock_transaction.customer_type = Mock() mock_transaction.customer_type.value = "regular" mock_transaction.item_count = 2 mock_transactions.append(mock_transaction) mock_db_session.query.return_value.join.return_value.outerjoin.return_value.filter.return_value.group_by.return_value.all.return_value = mock_transactions result = await ml_engine.detect_anomalies(mock_db_session, analysis_days=30) if result.get('available'): assert 'anomaly_types' in result assert 'risk_assessment' in result assert 'recommendations' in result def test_simple_forecast_algorithm(self, ml_engine): """Test the simple forecasting algorithm directly""" if not ml_engine.ml_available: pytest.skip("ML dependencies not available") # Generate test data with trend and seasonality test_data = np.array([10, 12, 8, 15, 20, 18, 14, 16, 22, 19, 15, 18] * 5) # 60 data points result = ml_engine._simple_forecast(test_data, periods=7) assert 'predictions' in result assert len(result['predictions']) == 7 assert 'confidence' in result assert 'mae' in result assert result['confidence'] >= 0.0 assert result['confidence'] <= 1.0 class TestPaymentGateways: """ Test suite for Payment Gateway integrations """ @pytest.fixture def vnpay_config(self): return { 'merchant_id': 'TEST_MERCHANT', 'secret_key': 'TEST_SECRET_KEY', 'api_url': 'https://sandbox.vnpayment.vn/paymentv2/vpcpay.html', 'return_url': 'https://test.com/return', 'notify_url': 'https://test.com/notify' } @pytest.fixture def momo_config(self): return { 'partner_code': 'MOMO_PARTNER', 'access_key': 'MOMO_ACCESS_KEY', 'secret_key': 'MOMO_SECRET_KEY', 'api_url': 'https://test-payment.momo.vn/v2/gateway/api/create', 'return_url': 'https://test.com/return', 'notify_url': 'https://test.com/notify' } def test_vnpay_gateway_initialization(self, vnpay_config): """Test VNPay gateway initializes correctly""" gateway = VNPayGateway(vnpay_config) assert gateway.merchant_id == 'TEST_MERCHANT' assert gateway.secret_key == 'TEST_SECRET_KEY' assert gateway.api_url == 'https://sandbox.vnpayment.vn/paymentv2/vpcpay.html' @pytest.mark.asyncio async def test_vnpay_create_payment(self, vnpay_config): """Test VNPay payment creation""" gateway = VNPayGateway(vnpay_config) payment_data = { 'order_id': 'TEST_ORDER_001', 'amount': 100000, # 100,000 VND 'description': 'Test payment', 'customer': { 'name': 'Test Customer', 'email': 'test@example.com', 'phone': '0901234567' }, 'ip_address': '127.0.0.1' } result = await gateway.create_payment(payment_data) assert result['success'] is True assert 'payment_url' in result assert result['gateway'] == 'vnpay' assert result['transaction_id'] == 'TEST_ORDER_001' assert result['amount'] == 100000.0 @pytest.mark.asyncio async def test_vnpay_verify_payment_invalid_hash(self, vnpay_config): """Test VNPay payment verification with invalid hash""" gateway = VNPayGateway(vnpay_config) verification_data = { 'vnp_TxnRef': 'TEST_ORDER_001', 'vnp_ResponseCode': '00', 'vnp_TransactionStatus': '00', 'vnp_Amount': '10000000', # 100,000 VND * 100 'vnp_SecureHash': 'invalid_hash' } result = await gateway.verify_payment('TEST_ORDER_001', verification_data) assert result['success'] is False assert result['status'] == PaymentStatus.FAILED.value assert 'Invalid secure hash' in result['error'] def test_momo_gateway_initialization(self, momo_config): """Test MoMo gateway initializes correctly""" gateway = MoMoGateway(momo_config) assert gateway.partner_code == 'MOMO_PARTNER' assert gateway.access_key == 'MOMO_ACCESS_KEY' assert gateway.secret_key == 'MOMO_SECRET_KEY' @pytest.mark.asyncio async def test_momo_create_payment_error(self, momo_config): """Test MoMo payment creation with API error""" gateway = MoMoGateway(momo_config) payment_data = { 'order_id': 'TEST_ORDER_001', 'amount': 100000, 'description': 'Test payment' } # Mock aiohttp response mock_response = AsyncMock() mock_response.json.return_value = { 'resultCode': 99, 'message': 'Test error' } with patch('aiohttp.ClientSession.post') as mock_post: mock_post.return_value.__aenter__.return_value = mock_response result = await gateway.create_payment(payment_data) assert result['success'] is False assert 'MoMo error' in result['error'] assert result['error_code'] == 99 def test_payment_gateway_manager(self, vnpay_config, momo_config): """Test Payment Gateway Manager""" manager = PaymentGatewayManager() vnpay = VNPayGateway(vnpay_config) momo = MoMoGateway(momo_config) manager.register_gateway('vnpay', vnpay, is_default=True) manager.register_gateway('momo', momo) assert manager.default_gateway == 'vnpay' assert len(manager.get_available_gateways()) == 2 assert manager.get_gateway('vnpay') == vnpay assert manager.get_gateway('momo') == momo class TestShippingAPIs: """ Test suite for Shipping API integrations """ @pytest.fixture def ghtk_config(self): return { 'base_url': 'https://services.giaohangtietkiem.vn', 'token': 'TEST_GHTK_TOKEN', 'shop_id': 'TEST_SHOP' } @pytest.fixture def ghn_config(self): return { 'base_url': 'https://dev-online-gateway.ghn.vn', 'token': 'TEST_GHN_TOKEN', 'shop_id': 123456 } def test_ghtk_api_initialization(self, ghtk_config): """Test GHTK API initializes correctly""" api = GHTKShippingAPI(ghtk_config) assert api.base_url == 'https://services.giaohangtietkiem.vn' assert api.token == 'TEST_GHTK_TOKEN' assert api.shop_id == 'TEST_SHOP' @pytest.mark.asyncio async def test_ghtk_get_shipping_rates(self, ghtk_config): """Test GHTK shipping rate calculation""" api = GHTKShippingAPI(ghtk_config) shipping_data = { 'origin': { 'province': 'Ha Noi', 'district': 'Cau Giay' }, 'destination': { 'province': 'TP. Ho Chi Minh', 'district': 'Quan 1', 'address': '123 Test Street' }, 'weight': 1000, 'value': 500000 } # Mock successful API response mock_response = AsyncMock() mock_response.json.return_value = { 'success': True, 'fee': { 'fee': 25000, 'ship_fee_only': 20000, 'insurance_fee': 5000, 'pick_fee': 0, 'deliver_fee': 0, 'return_fee': 15000, 'delivery_date': '2025-09-28', 'distance': 1650 } } with patch('aiohttp.ClientSession.get') as mock_get: mock_get.return_value.__aenter__.return_value = mock_response result = await api.get_shipping_rates(shipping_data) assert result['success'] is True assert result['provider'] == 'ghtk' assert len(result['services']) == 1 assert result['services'][0]['fee'] == 25000 @pytest.mark.asyncio async def test_ghtk_create_shipment(self, ghtk_config): """Test GHTK shipment creation""" api = GHTKShippingAPI(ghtk_config) shipment_data = { 'order_id': 'TEST_SHIP_001', 'sender': { 'name': 'Test Sender', 'phone': '0901234567', 'address': '123 Sender St', 'province': 'Ha Noi', 'district': 'Cau Giay', 'ward': 'Dich Vong' }, 'recipient': { 'name': 'Test Recipient', 'phone': '0907654321', 'address': '456 Recipient St', 'province': 'TP. Ho Chi Minh', 'district': 'Quan 1', 'ward': 'Ben Nghe' }, 'items': [ { 'name': 'Test Product', 'weight': 500, 'quantity': 2, 'price': 250000 } ], 'cod_amount': 500000, 'note': 'Handle with care' } # Mock successful shipment creation mock_response = AsyncMock() mock_response.json.return_value = { 'success': True, 'order': { 'label': 'GHTK12345678', 'partner_id': 'P123456', 'status_text': 'Cho lay hang', 'estimated_pick_time': '2025-09-27 14:00:00', 'estimated_deliver_time': '2025-09-28 18:00:00', 'fee': 25000, 'insurance_fee': 5000 } } with patch('aiohttp.ClientSession.post') as mock_post: mock_post.return_value.__aenter__.return_value = mock_response result = await api.create_shipment(shipment_data) assert result['success'] is True assert result['tracking_number'] == 'GHTK12345678' assert result['provider'] == 'ghtk' assert result['fee'] == 25000 def test_ghn_api_initialization(self, ghn_config): """Test GHN API initializes correctly""" api = GHNShippingAPI(ghn_config) assert api.base_url == 'https://dev-online-gateway.ghn.vn' assert api.token == 'TEST_GHN_TOKEN' assert api.shop_id == 123456 def test_shipping_api_manager(self, ghtk_config, ghn_config): """Test Shipping API Manager""" manager = ShippingAPIManager() ghtk = GHTKShippingAPI(ghtk_config) ghn = GHNShippingAPI(ghn_config) manager.register_api('ghtk', ghtk, is_default=True) manager.register_api('ghn', ghn) assert manager.default_api == 'ghtk' assert len(manager.get_available_apis()) == 2 assert manager.get_api('ghtk') == ghtk assert manager.get_api('ghn') == ghn class TestAdvancedSecurity: """ Test suite for Advanced Security features """ @pytest.fixture def rate_limiter(self): return RateLimiter() @pytest.fixture def mock_request(self): request = Mock() request.client = Mock() request.client.host = '192.168.1.100' request.headers = {'user-agent': 'Test Agent'} request.query_params = {} return request def test_rate_limiter_initialization(self, rate_limiter): """Test rate limiter initializes correctly""" assert rate_limiter is not None assert hasattr(rate_limiter, 'requests') assert hasattr(rate_limiter, 'blocked_ips') def test_rate_limiter_allow_request(self, rate_limiter, mock_request): """Test rate limiter allows requests within limit""" result = rate_limiter.is_allowed(mock_request, max_requests=10, window_seconds=60) assert result['allowed'] is True assert result['current_requests'] == 1 assert result['remaining'] == 9 def test_rate_limiter_block_request(self, rate_limiter, mock_request): """Test rate limiter blocks requests over limit""" # Make requests up to limit for _ in range(5): rate_limiter.is_allowed(mock_request, max_requests=5, window_seconds=60) # This should be blocked result = rate_limiter.is_allowed(mock_request, max_requests=5, window_seconds=60) assert result['allowed'] is False assert result['reason'] == 'rate_limit_exceeded' def test_rate_limiter_ip_blocking(self, rate_limiter): """Test IP blocking functionality""" test_ip = '192.168.1.100' # Block IP rate_limiter.block_ip(test_ip, duration_seconds=300, reason='Test block') blocked_ips = rate_limiter.get_blocked_ips() assert len(blocked_ips) == 1 assert blocked_ips[0]['ip'] == test_ip assert blocked_ips[0]['reason'] == 'Test block' # Unblock IP rate_limiter.unblock_ip(test_ip) blocked_ips = rate_limiter.get_blocked_ips() assert len(blocked_ips) == 0 def test_security_headers(self): """Test security headers generation""" headers = SecurityHeaders.get_security_headers() assert 'X-XSS-Protection' in headers assert 'X-Content-Type-Options' in headers assert 'X-Frame-Options' in headers assert 'Content-Security-Policy' in headers assert 'Strict-Transport-Security' in headers # Check specific values assert headers['X-XSS-Protection'] == '1; mode=block' assert headers['X-Content-Type-Options'] == 'nosniff' assert headers['X-Frame-Options'] == 'DENY' def test_input_validator_sql_injection(self): """Test SQL injection detection""" validator = InputValidator() # Test positive cases (should detect) sql_attacks = [ "'; DROP TABLE users; --", "1' OR '1'='1", "UNION SELECT * FROM passwords", "admin'/*", "1; DELETE FROM products" ] for attack in sql_attacks: assert validator.check_sql_injection(attack) is True, f"Failed to detect SQL injection in: {attack}" # Test negative cases (should not detect) safe_inputs = [ "normal text input", "user@example.com", "Product name with numbers 123", "Address line 1, Street 2" ] for safe_input in safe_inputs: assert validator.check_sql_injection(safe_input) is False, f"False positive for: {safe_input}" def test_input_validator_xss(self): """Test XSS detection""" validator = InputValidator() # Test positive cases (should detect) xss_attacks = [ "<script>alert('xss')</script>", "<img src=x onerror=alert(1)>", "javascript:alert('xss')", "<iframe src='javascript:alert(1)'></iframe>", "<body onload=alert('xss')>" ] for attack in xss_attacks: assert validator.check_xss(attack) is True, f"Failed to detect XSS in: {attack}" # Test negative cases safe_inputs = [ "This is normal text", "Email: user@example.com", "Price: $123.45", "HTML entities: &lt;b&gt;bold&lt;/b&gt;" ] for safe_input in safe_inputs: assert validator.check_xss(safe_input) is False, f"False positive for: {safe_input}" def test_input_validator_path_traversal(self): """Test path traversal detection""" validator = InputValidator() # Test positive cases (should detect) traversal_attacks = [ "../../../etc/passwd", "..\\..\\windows\\system32", "%2e%2e/etc/passwd", "....//....//etc/passwd", "..%2f..%2f..%2fetc%2fpasswd" ] for attack in traversal_attacks: assert validator.check_path_traversal(attack) is True, f"Failed to detect path traversal in: {attack}" # Test negative cases safe_paths = [ "documents/file.txt", "images/photo.jpg", "reports/2023/summary.pdf", "valid_file_name.doc" ] for safe_path in safe_paths: assert validator.check_path_traversal(safe_path) is False, f"False positive for: {safe_path}" def test_input_validator_sanitization(self): """Test input sanitization""" validator = InputValidator() test_cases = [ ("Normal text", "Normal text"), ("<script>alert('xss')</script>", "&lt;script&gt;alert('xss')&lt;/script&gt;"), ("Text with\x00null byte", "Text withnull byte"), (" Leading and trailing spaces ", "Leading and trailing spaces"), ("Text with\tcontrol\x08characters", "Text with\tcontrolcharacters") ] for input_text, expected in test_cases: result = validator.sanitize_input(input_text) assert result == expected, f"Sanitization failed for '{input_text}'. Expected: '{expected}', Got: '{result}'" def test_input_validator_email(self): """Test email validation""" validator = InputValidator() valid_emails = [ "test@example.com", "user.name@domain.co.uk", "admin123@test-site.org", "contact+support@company.com" ] invalid_emails = [ "invalid.email", "@domain.com", "user@", "user..name@domain.com", "user name@domain.com" ] for email in valid_emails: assert validator.validate_email(email) is True, f"Valid email rejected: {email}" for email in invalid_emails: assert validator.validate_email(email) is False, f"Invalid email accepted: {email}" def test_input_validator_vietnamese_phone(self): """Test Vietnamese phone number validation""" validator = InputValidator() valid_phones = [ "0901234567", "+84901234567", "0123456789", # Landline "84901234567", "09012345678" # 11 digits mobile ] invalid_phones = [ "123456789", # Too short "01234567890", # Invalid prefix "abcd123456", # Contains letters "+1234567890" # Wrong country code ] for phone in valid_phones: assert validator.validate_phone(phone) is True, f"Valid phone rejected: {phone}" for phone in invalid_phones: assert validator.validate_phone(phone) is False, f"Invalid phone accepted: {phone}" @pytest.mark.asyncio async def test_security_audit_logger(self, mock_db_session): """Test security audit logging""" logger = SecurityAuditLogger(lambda: mock_db_session) await logger.log_security_event( event_type=SecurityEventType.LOGIN_ATTEMPT, user_id=123, ip_address='192.168.1.100', user_agent='Test Agent', threat_level=SecurityThreatLevel.LOW, action_taken=SecurityAction.ALLOW ) assert len(logger.log_queue) == 1 event = logger.log_queue[0] assert event['event_type'] == 'login_attempt' assert event['user_id'] == 123 assert event['ip_address'] == '192.168.1.100' @pytest.mark.asyncio async def test_vulnerability_scanner_dependencies(self): """Test vulnerability scanner dependencies check""" scanner = VulnerabilityScanner() result = await scanner.scan_dependencies() assert 'scan_date' in result assert 'total_packages' in result assert 'vulnerable_packages' in result assert 'recommendations' in result assert isinstance(result['recommendations'], list) assert len(result['recommendations']) > 0 @pytest.mark.asyncio async def test_vulnerability_scanner_configuration(self): """Test vulnerability scanner configuration check""" scanner = VulnerabilityScanner() result = await scanner.scan_configuration() assert 'scan_date' in result assert 'issues_found' in result assert 'recommendations' in result assert 'overall_score' in result assert isinstance(result['overall_score'], int) assert 0 <= result['overall_score'] <= 100 @pytest.mark.asyncio async def test_advanced_security_manager_initialization(self, mock_db_session): """Test advanced security manager initialization""" manager = AdvancedSecurityManager(lambda: mock_db_session) assert manager.rate_limiter is not None assert manager.security_headers is not None assert manager.input_validator is not None assert manager.audit_logger is not None assert manager.vulnerability_scanner is not None assert isinstance(manager.settings, dict) @pytest.mark.asyncio async def test_advanced_security_manager_request_validation(self, mock_db_session, mock_request): """Test comprehensive request validation""" manager = AdvancedSecurityManager(lambda: mock_db_session) # Test normal request result = await manager.validate_request(mock_request) assert result['is_valid'] is True assert result['action'] == SecurityAction.ALLOW assert result['threat_level'] == SecurityThreatLevel.LOW # Test request with malicious query params mock_request.query_params = {'search': "'; DROP TABLE users; --"} result = await manager.validate_request(mock_request) assert result['is_valid'] is False assert result['action'] == SecurityAction.BLOCK assert result['threat_level'] == SecurityThreatLevel.HIGH def test_password_strength_checker(self, mock_db_session): """Test password strength checking""" manager = AdvancedSecurityManager(lambda: mock_db_session) # Test weak password weak_result = manager.check_password_strength('123') assert weak_result['is_strong'] is False assert weak_result['strength'] == 'Weak' assert len(weak_result['issues']) > 0 # Test strong password strong_result = manager.check_password_strength('StrongPass123!') assert strong_result['is_strong'] is True assert strong_result['strength'] == 'Strong' assert len(strong_result['issues']) == 0 # Test medium password medium_result = manager.check_password_strength('password123') assert medium_result['is_strong'] is False assert medium_result['strength'] in ['Weak', 'Medium'] @pytest.mark.asyncio async def test_security_report_generation(self, mock_db_session): """Test comprehensive security report generation""" manager = AdvancedSecurityManager(lambda: mock_db_session) report = await manager.generate_security_report() assert 'report_generated' in report assert 'overall_security_score' in report assert 'dependency_security' in report assert 'configuration_security' in report assert 'security_events' in report assert 'blocked_ips' in report assert 'recommendations' in report assert isinstance(report['overall_security_score'], int) assert 0 <= report['overall_security_score'] <= 100 assert isinstance(report['recommendations'], list) class TestPWAFeatures: """ Test suite for PWA functionality (mock tests for JS features) """ def test_manifest_structure(self): """Test PWA manifest structure""" # This would test the manifest.json structure expected_fields = [ 'name', 'short_name', 'description', 'start_url', 'display', 'background_color', 'theme_color', 'icons', 'shortcuts' ] # In a real test, you would load and parse the manifest.json file manifest = { 'name': 'FADO CRM - He Thong Quan Ly Khach Hang', 'short_name': 'FADO CRM', 'description': 'He thong CRM chuyen nghiep', 'start_url': '/', 'display': 'standalone', 'background_color': '#ffffff', 'theme_color': '#4A90E2', 'icons': [], 'shortcuts': [] } for field in expected_fields: assert field in manifest, f"Missing required field: {field}" def test_service_worker_caching_strategy(self): """Test service worker caching strategy configuration""" # This would test the service worker configuration cache_strategies = { 'static_resources': 'cache_first', 'api_endpoints': 'network_first', 'images': 'cache_first' } for resource_type, strategy in cache_strategies.items(): assert strategy in ['cache_first', 'network_first', 'stale_while_revalidate'] class TestIntegrationFeatures: """ Integration tests for Phase 6 features working together """ @pytest.mark.asyncio async def test_security_with_payment_integration(self, mock_db_session): """Test security features working with payment processing""" # Initialize security manager security_manager = AdvancedSecurityManager(lambda: mock_db_session) # Mock a payment request mock_request = Mock() mock_request.client = Mock() mock_request.client.host = '192.168.1.100' mock_request.headers = {'user-agent': 'Test Payment Agent'} mock_request.query_params = {'amount': '100000', 'order_id': 'TEST_001'} # Validate request through security validation_result = await security_manager.validate_request(mock_request) assert validation_result['is_valid'] is True # Process payment with validated request payment_config = { 'merchant_id': 'TEST_MERCHANT', 'secret_key': 'TEST_SECRET_KEY', 'api_url': 'https://sandbox.vnpayment.vn/paymentv2/vpcpay.html', 'return_url': 'https://test.com/return', 'notify_url': 'https://test.com/notify' } gateway = VNPayGateway(payment_config) payment_result = await gateway.create_payment({ 'order_id': 'TEST_001', 'amount': 100000, 'description': 'Secure payment test' }) assert payment_result['success'] is True assert 'payment_url' in payment_result @pytest.mark.asyncio async def test_ml_with_security_monitoring(self, mock_db_session): """Test ML engine working with security monitoring""" # Initialize components security_manager = AdvancedSecurityManager(lambda: mock_db_session) ml_engine = AdvancedMLEngine() if not ml_engine.ml_available: pytest.skip("ML dependencies not available") # Mock transaction data that might indicate fraud mock_transactions = [] base_time = datetime.now() # Create normal transactions for i in range(20): transaction = Mock() transaction.id = i transaction.ma_don_hang = f"ORDER_{i:04d}" transaction.khach_hang_id = i % 5 transaction.tong_tien = 100000 + (i * 10000) # Normal amounts transaction.ngay_tao = base_time - timedelta(hours=i) transaction.trang_thai = Mock() transaction.trang_thai.value = "completed" transaction.customer_name = f"Customer {i % 5}" transaction.email = f"customer{i%5}@test.com" transaction.so_dien_thoai = f"090000000{i % 5}" transaction.customer_type = Mock() transaction.customer_type.value = "regular" transaction.item_count = 2 mock_transactions.append(transaction) # Add suspicious transaction suspicious_transaction = Mock() suspicious_transaction.id = 999 suspicious_transaction.ma_don_hang = "SUSPICIOUS_999" suspicious_transaction.khach_hang_id = 999 suspicious_transaction.tong_tien = 50000000 # Unusually high amount suspicious_transaction.ngay_tao = base_time suspicious_transaction.trang_thai = Mock() suspicious_transaction.trang_thai.value = "completed" suspicious_transaction.customer_name = "Suspicious Customer" suspicious_transaction.email = "suspicious@test.com" suspicious_transaction.so_dien_thoai = "0900000999" suspicious_transaction.customer_type = Mock() suspicious_transaction.customer_type.value = "new" suspicious_transaction.item_count = 1 mock_transactions.append(suspicious_transaction) mock_db_session.query.return_value.join.return_value.outerjoin.return_value.filter.return_value.group_by.return_value.all.return_value = mock_transactions # Run anomaly detection anomaly_result = await ml_engine.detect_anomalies(mock_db_session, analysis_days=7) if anomaly_result.get('available'): # Check if suspicious activity was detected risk_assessment = anomaly_result.get('risk_assessment', {}) # If high risk detected, log security event if risk_assessment.get('risk_level') == 'HIGH': await security_manager.audit_logger.log_security_event( event_type=SecurityEventType.SUSPICIOUS_ACTIVITY, threat_level=SecurityThreatLevel.HIGH, action_taken=SecurityAction.WARN, details={'ml_anomaly_detection': anomaly_result} ) assert len(security_manager.audit_logger.log_queue) > 0 # Performance and Load Tests class TestPerformance: """ Performance tests for Phase 6 features """ @pytest.mark.asyncio async def test_rate_limiter_performance(self): """Test rate limiter performance under load""" rate_limiter = RateLimiter() # Create mock requests mock_requests = [] for i in range(100): request = Mock() request.client = Mock() request.client.host = f'192.168.1.{i % 10}' # 10 different IPs request.headers = {'user-agent': 'Load Test Agent'} request.query_params = {} mock_requests.append(request) start_time = time.time() # Process all requests results = [] for request in mock_requests: result = rate_limiter.is_allowed(request, max_requests=50, window_seconds=3600) results.append(result) end_time = time.time() processing_time = end_time - start_time # Verify performance (should process 100 requests in under 1 second) assert processing_time < 1.0, f"Rate limiter too slow: {processing_time:.2f}s for 100 requests" # Verify correctness allowed_count = sum(1 for r in results if r['allowed']) assert allowed_count > 0, "No requests were allowed" @pytest.mark.asyncio async def test_input_validation_performance(self): """Test input validation performance""" validator = InputValidator() # Create test inputs test_inputs = [ "Normal text input", "'; DROP TABLE users; --", "<script>alert('xss')</script>", "../../../etc/passwd", "user@example.com", "Very long input " * 100, ] * 100 # 600 total inputs start_time = time.time() for input_text in test_inputs: validator.check_sql_injection(input_text) validator.check_xss(input_text) validator.check_path_traversal(input_text) end_time = time.time() processing_time = end_time - start_time # Should process 600 validations in under 1 second assert processing_time < 1.0, f"Input validation too slow: {processing_time:.2f}s for 600 validations" # Cleanup and Fixtures @pytest.fixture(scope="session") def event_loop(): """Create event loop for async tests""" loop = asyncio.get_event_loop_policy().new_event_loop() yield loop loop.close() def test_phase6_modules_import(): """Test that all Phase 6 modules can be imported successfully""" try: from ml_engine import AdvancedMLEngine from integrations.payment_gateways import PaymentGatewayManager from integrations.shipping_apis import ShippingAPIManager from security.advanced_security import AdvancedSecurityManager assert True, "All Phase 6 modules imported successfully" except ImportError as e: pytest.fail(f"Failed to import Phase 6 modules: {e}") if __name__ == "__main__": pytest.main([__file__, "-v", "--tb=short"])
