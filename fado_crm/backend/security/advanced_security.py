# FADO CRM - Advanced Security Features # Bao mat nang cao: Rate limiting, Security headers, Audit logging, Vulnerability scanning from typing import Dict, List, Optional, Any, Set from datetime import datetime, timedelta from enum import Enum import hashlib import hmac import secrets import json import asyncio import re from functools import wraps from collections import defaultdict, deque import ipaddress import time import uuid from fastapi import Request, Response, HTTPException, Depends from fastapi.security import HTTPBearer from sqlalchemy.orm import Session from sqlalchemy import func # Security enums class SecurityThreatLevel(Enum): LOW = "low" MEDIUM = "medium" HIGH = "high" CRITICAL = "critical" class SecurityEventType(Enum): LOGIN_ATTEMPT = "login_attempt" LOGIN_SUCCESS = "login_success" LOGIN_FAILED = "login_failed" RATE_LIMIT_EXCEEDED = "rate_limit_exceeded" SUSPICIOUS_ACTIVITY = "suspicious_activity" UNAUTHORIZED_ACCESS = "unauthorized_access" DATA_BREACH_ATTEMPT = "data_breach_attempt" SQL_INJECTION_ATTEMPT = "sql_injection_attempt" XSS_ATTEMPT = "xss_attempt" CSRF_ATTEMPT = "csrf_attempt" PASSWORD_BRUTE_FORCE = "password_brute_force" ADMIN_ACTION = "admin_action" DATA_EXPORT = "data_export" FILE_UPLOAD = "file_upload" API_ABUSE = "api_abuse" class SecurityAction(Enum): ALLOW = "allow" WARN = "warn" BLOCK = "block" TEMPORARY_BLOCK = "temporary_block" PERMANENT_BLOCK = "permanent_block" # Rate Limiter Implementation class RateLimiter: """ Advanced Rate Limiter voi sliding window va multiple strategies """ def __init__(self): # Store: {key: deque of timestamps} self.requests = defaultdict(deque) # Blocked IPs: {ip: (block_until, reason)} self.blocked_ips = {} # Cleanup task self._cleanup_task = None def _cleanup_old_requests(self): """Cleanup old request records""" now = time.time() for key in list(self.requests.keys()): while self.requests[key] and self.requests[key][0] < now - 3600: # Keep last hour self.requests[key].popleft() if not self.requests[key]: del self.requests[key] def _get_rate_limit_key(self, request: Request, identifier: str = None) -> str: """Generate unique key for rate limiting""" if identifier: return f"custom:{identifier}" # Use IP address as primary identifier client_ip = self._get_client_ip(request) return f"ip:{client_ip}" def _get_client_ip(self, request: Request) -> str: """Get real client IP from request""" # Check various headers for real IP headers_to_check = [ 'CF-Connecting-IP', # Cloudflare 'X-Real-IP', # Nginx 'X-Forwarded-For', # Standard 'X-Client-IP', # Apache ] for header in headers_to_check: if header in request.headers: ip = request.headers[header].split(',')[0].strip() try: # Validate IP address ipaddress.ip_address(ip) return ip except ValueError: continue # Fallback to direct client return request.client.host if request.client else "unknown" def is_allowed(self, request: Request, max_requests: int, window_seconds: int, identifier: str = None) -> Dict[str, Any]: """ Check if request is allowed based on rate limits """ now = time.time() key = self._get_rate_limit_key(request, identifier) client_ip = self._get_client_ip(request) # Check if IP is blocked if client_ip in self.blocked_ips: block_until, reason = self.blocked_ips[client_ip] if now < block_until: return { 'allowed': False, 'reason': 'ip_blocked', 'block_reason': reason, 'retry_after': int(block_until - now), 'remaining': 0, 'reset_time': block_until } else: # Unblock expired blocks del self.blocked_ips[client_ip] # Clean old requests request_times = self.requests[key] cutoff_time = now - window_seconds # Remove old requests outside the window while request_times and request_times[0] < cutoff_time: request_times.popleft() # Check rate limit current_requests = len(request_times) if current_requests >= max_requests: # Rate limit exceeded return { 'allowed': False, 'reason': 'rate_limit_exceeded', 'current_requests': current_requests, 'max_requests': max_requests, 'window_seconds': window_seconds, 'retry_after': int(window_seconds - (now - request_times[0])), 'remaining': 0, 'reset_time': request_times[0] + window_seconds } # Add current request request_times.append(now) return { 'allowed': True, 'current_requests': current_requests + 1, 'max_requests': max_requests, 'remaining': max_requests - current_requests - 1, 'reset_time': now + window_seconds } def block_ip(self, ip: str, duration_seconds: int, reason: str): """Block an IP address""" block_until = time.time() + duration_seconds self.blocked_ips[ip] = (block_until, reason) def unblock_ip(self, ip: str): """Unblock an IP address""" if ip in self.blocked_ips: del self.blocked_ips[ip] def get_blocked_ips(self) -> List[Dict[str, Any]]: """Get list of currently blocked IPs""" now = time.time() blocked = [] for ip, (block_until, reason) in self.blocked_ips.items(): if block_until > now: blocked.append({ 'ip': ip, 'block_until': datetime.fromtimestamp(block_until).isoformat(), 'remaining_seconds': int(block_until - now), 'reason': reason }) return blocked # Security Headers Manager class SecurityHeaders: """ Manager for security headers """ @staticmethod def get_security_headers() -> Dict[str, str]: """Get standard security headers""" return { # XSS Protection 'X-XSS-Protection': '1; mode=block', # Content Type Options 'X-Content-Type-Options': 'nosniff', # Frame Options 'X-Frame-Options': 'DENY', # Referrer Policy 'Referrer-Policy': 'strict-origin-when-cross-origin', # Content Security Policy 'Content-Security-Policy': ( "default-src 'self'; " "script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net https://cdnjs.cloudflare.com; " "style-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net https://cdnjs.cloudflare.com; " "img-src 'self' data: https:; " "font-src 'self' https://cdnjs.cloudflare.com; " "connect-src 'self' https://api.github.com; " "frame-ancestors 'none';" ), # HSTS (HTTPS Strict Transport Security) 'Strict-Transport-Security': 'max-age=31536000; includeSubDomains', # Permissions Policy (formerly Feature Policy) 'Permissions-Policy': ( 'camera=(), ' 'microphone=(), ' 'geolocation=(), ' 'payment=()' ), # Custom security headers 'X-Powered-By': '', # Remove server fingerprinting 'Server': '', # Remove server fingerprinting } @staticmethod def apply_security_headers(response: Response): """Apply security headers to response""" headers = SecurityHeaders.get_security_headers() for header, value in headers.items(): if value: # Only set non-empty values response.headers[header] = value elif header in ['X-Powered-By', 'Server']: # Remove these headers response.headers.pop(header, None) # Input Validation and Sanitization class InputValidator: """ Advanced input validation va sanitization """ # SQL Injection patterns SQL_INJECTION_PATTERNS = [ r"(\bUNION\b.*\bSELECT\b)", r"(\bSELECT\b.*\bFROM\b.*\bWHERE\b)", r"(\bINSERT\b.*\bINTO\b.*\bVALUES\b)", r"(\bUPDATE\b.*\bSET\b)", r"(\bDELETE\b.*\bFROM\b)", r"(\bDROP\b.*\bTABLE\b)", r"(\bCREATE\b.*\bTABLE\b)", r"(\bALTER\b.*\bTABLE\b)", r"(\bEXEC\b.*\()", r"(\bSP_\w+)", r"(--)", r"(/\*.*\*/)", r"(\bOR\b.*=.*)", r"(\bAND\b.*=.*)", r"(';.*--)", r"('.*OR.*'.*=.*')", ] # XSS patterns XSS_PATTERNS = [ r"<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>", r"javascript:", r"vbscript:", r"onload\s*=", r"onerror\s*=", r"onclick\s*=", r"onmouseover\s*=", r"onfocus\s*=", r"onblur\s*=", r"<iframe\b", r"<object\b", r"<embed\b", r"<applet\b", r"<meta\b.*refresh", r"<link\b.*href\s*=.*javascript:", ] # Path traversal patterns PATH_TRAVERSAL_PATTERNS = [ r"\.\./", r"\.\.\x5c", r"\x2e\x2e/", r"\x2e\x2e\x5c", r"\.\.%2f", r"\.\.%5c", r"%2e%2e/", r"%2e%2e%5c", ] @classmethod def check_sql_injection(cls, input_string: str) -> bool: """Check for SQL injection patterns""" if not input_string: return False input_lower = input_string.lower() for pattern in cls.SQL_INJECTION_PATTERNS: if re.search(pattern, input_lower, re.IGNORECASE): return True return False @classmethod def check_xss(cls, input_string: str) -> bool: """Check for XSS patterns""" if not input_string: return False input_lower = input_string.lower() for pattern in cls.XSS_PATTERNS: if re.search(pattern, input_lower, re.IGNORECASE | re.DOTALL): return True return False @classmethod def check_path_traversal(cls, input_string: str) -> bool: """Check for path traversal patterns""" if not input_string: return False input_lower = input_string.lower() for pattern in cls.PATH_TRAVERSAL_PATTERNS: if re.search(pattern, input_lower, re.IGNORECASE): return True return False @classmethod def sanitize_input(cls, input_string: str, max_length: int = 1000) -> str: """Sanitize user input""" if not input_string: return "" # Truncate if too long if len(input_string) > max_length: input_string = input_string[:max_length] # Remove null bytes input_string = input_string.replace('\x00', '') # Remove control characters except newline and tab input_string = ''.join(char for char in input_string if ord(char) >= 32 or char in '\n\t') # Basic HTML escape input_string = input_string.replace('<', '&lt;').replace('>', '&gt;') return input_string.strip() @classmethod def validate_email(cls, email: str) -> bool: """Validate email format""" pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$' return re.match(pattern, email) is not None @classmethod def validate_phone(cls, phone: str) -> bool: """Validate Vietnamese phone number""" # Remove all non-digits phone_digits = re.sub(r'\D', '', phone) # Vietnamese phone patterns patterns = [ r'^(0|\+84)(3[2-9]|5[689]|7[06-9]|8[1-689]|9[0-46-9])[0-9]{7}$', # Mobile r'^(0|\+84)(2[0-9])[0-9]{8}$', # Landline ] for pattern in patterns: if re.match(pattern, phone_digits): return True return False # Security Audit Logger class SecurityAuditLogger: """ Security audit logging system """ def __init__(self, db_session_factory): self.db_session_factory = db_session_factory self.log_queue = [] async def log_security_event(self, event_type: SecurityEventType, user_id: Optional[int] = None, ip_address: str = "unknown", user_agent: str = "", request_data: Dict[str, Any] = None, threat_level: SecurityThreatLevel = SecurityThreatLevel.LOW, action_taken: SecurityAction = SecurityAction.ALLOW, details: Dict[str, Any] = None): """Log a security event""" event = { 'id': str(uuid.uuid4()), 'timestamp': datetime.utcnow().isoformat(), 'event_type': event_type.value, 'user_id': user_id, 'ip_address': ip_address, 'user_agent': user_agent, 'request_data': request_data or {}, 'threat_level': threat_level.value, 'action_taken': action_taken.value, 'details': details or {}, 'session_id': self._generate_session_id(), } # Add to queue for batch processing self.log_queue.append(event) # Process immediately for critical events if threat_level == SecurityThreatLevel.CRITICAL: await self._process_log_queue() # Trigger alerts for high-threat events if threat_level in [SecurityThreatLevel.HIGH, SecurityThreatLevel.CRITICAL]: await self._trigger_security_alert(event) def _generate_session_id(self) -> str: """Generate a session ID for grouping related events""" return secrets.token_urlsafe(16) async def _process_log_queue(self): """Process queued log entries""" if not self.log_queue: return # In a real implementation, you would save to database # For now, we'll just print to console (can be replaced with proper logging) for event in self.log_queue: print(f"SECURITY_EVENT: {json.dumps(event, indent=2)}") self.log_queue.clear() async def _trigger_security_alert(self, event: Dict[str, Any]): """Trigger security alerts for high-threat events""" # This could send notifications to security team # For now, we'll just log it print(f" SECURITY ALERT: {event['event_type']} - {event['threat_level']}") print(f"Details: {json.dumps(event, indent=2)}") async def get_security_events(self, start_date: Optional[datetime] = None, end_date: Optional[datetime] = None, event_types: Optional[List[SecurityEventType]] = None, threat_levels: Optional[List[SecurityThreatLevel]] = None, user_id: Optional[int] = None, ip_address: Optional[str] = None, limit: int = 100) -> List[Dict[str, Any]]: """Query security events with filters""" # This would query the database in a real implementation # For now, return empty list return [] async def get_security_summary(self, days: int = 30) -> Dict[str, Any]: """Get security summary for the specified period""" # This would generate security metrics from database return { 'period_days': days, 'total_events': 0, 'events_by_type': {}, 'events_by_threat_level': {}, 'top_threatening_ips': [], 'blocked_attempts': 0, 'successful_attacks': 0, } # Vulnerability Scanner class VulnerabilityScanner: """ Basic vulnerability scanner for common security issues """ def __init__(self): self.scan_results = [] async def scan_dependencies(self) -> Dict[str, Any]: """Scan dependencies for known vulnerabilities""" # In a real implementation, this would check against vulnerability databases # For now, return a placeholder return { 'scan_date': datetime.utcnow().isoformat(), 'total_packages': 0, 'vulnerable_packages': [], 'recommendations': [ 'Keep all dependencies up to date', 'Use dependency scanning tools like Safety or Snyk', 'Monitor security advisories for used packages' ] } async def scan_configuration(self) -> Dict[str, Any]: """Scan system configuration for security issues""" issues = [] recommendations = [] # Check for common misconfigurations checks = [ { 'name': 'Debug Mode', 'check': 'Ensure debug mode is disabled in production', 'severity': 'HIGH' }, { 'name': 'Default Credentials', 'check': 'Ensure no default passwords are in use', 'severity': 'CRITICAL' }, { 'name': 'HTTPS Configuration', 'check': 'Ensure HTTPS is properly configured', 'severity': 'HIGH' }, { 'name': 'Database Encryption', 'check': 'Ensure database connections are encrypted', 'severity': 'MEDIUM' }, { 'name': 'File Permissions', 'check': 'Ensure proper file permissions are set', 'severity': 'MEDIUM' } ] for check in checks: # In a real implementation, you would actually perform these checks recommendations.append(f"{check['name']}: {check['check']}") return { 'scan_date': datetime.utcnow().isoformat(), 'issues_found': issues, 'recommendations': recommendations, 'overall_score': 85 # Mock security score } async def scan_endpoints(self, base_url: str) -> Dict[str, Any]: """Scan API endpoints for common vulnerabilities""" # This would perform actual security testing on endpoints return { 'scan_date': datetime.utcnow().isoformat(), 'base_url': base_url, 'endpoints_tested': 0, 'vulnerabilities_found': [], 'recommendations': [ 'Implement proper input validation', 'Use parameterized queries to prevent SQL injection', 'Implement proper authentication and authorization', 'Add rate limiting to prevent abuse', 'Use HTTPS for all endpoints' ] } # Advanced Security Manager class AdvancedSecurityManager: """ Main security manager coordinating all security features """ def __init__(self, db_session_factory): self.rate_limiter = RateLimiter() self.security_headers = SecurityHeaders() self.input_validator = InputValidator() self.audit_logger = SecurityAuditLogger(db_session_factory) self.vulnerability_scanner = VulnerabilityScanner() # Security settings self.settings = { 'max_login_attempts': 5, 'login_lockout_duration': 900, # 15 minutes 'session_timeout': 3600, # 1 hour 'password_min_length': 8, 'require_2fa': False, 'allowed_file_types': ['.jpg', '.jpeg', '.png', '.pdf', '.doc', '.docx'], 'max_file_size': 10 * 1024 * 1024, # 10MB } async def validate_request(self, request: Request) -> Dict[str, Any]: """Comprehensive request validation""" validation_result = { 'is_valid': True, 'issues': [], 'action': SecurityAction.ALLOW, 'threat_level': SecurityThreatLevel.LOW } # Rate limiting check rate_check = self.rate_limiter.is_allowed(request, max_requests=100, window_seconds=3600) if not rate_check['allowed']: validation_result['is_valid'] = False validation_result['issues'].append('Rate limit exceeded') validation_result['action'] = SecurityAction.TEMPORARY_BLOCK validation_result['threat_level'] = SecurityThreatLevel.MEDIUM await self.audit_logger.log_security_event( event_type=SecurityEventType.RATE_LIMIT_EXCEEDED, ip_address=self.rate_limiter._get_client_ip(request), user_agent=request.headers.get('user-agent', ''), threat_level=SecurityThreatLevel.MEDIUM, action_taken=SecurityAction.TEMPORARY_BLOCK ) # Input validation for query parameters and form data if hasattr(request, 'query_params'): for key, value in request.query_params.items(): if self._check_malicious_input(str(value)): validation_result['is_valid'] = False validation_result['issues'].append(f'Malicious input detected in parameter: {key}') validation_result['action'] = SecurityAction.BLOCK validation_result['threat_level'] = SecurityThreatLevel.HIGH return validation_result def _check_malicious_input(self, input_str: str) -> bool: """Check if input contains malicious patterns""" if self.input_validator.check_sql_injection(input_str): return True if self.input_validator.check_xss(input_str): return True if self.input_validator.check_path_traversal(input_str): return True return False async def apply_security_measures(self, request: Request, response: Response): """Apply comprehensive security measures""" # Apply security headers self.security_headers.apply_security_headers(response) # Log request for audit await self.audit_logger.log_security_event( event_type=SecurityEventType.API_ABUSE, # This would be determined by endpoint ip_address=self.rate_limiter._get_client_ip(request), user_agent=request.headers.get('user-agent', ''), request_data={'method': request.method, 'url': str(request.url)}, threat_level=SecurityThreatLevel.LOW, action_taken=SecurityAction.ALLOW ) def check_password_strength(self, password: str) -> Dict[str, Any]: """Check password strength""" issues = [] score = 0 if len(password) < self.settings['password_min_length']: issues.append(f'Password must be at least {self.settings["password_min_length"]} characters long') else: score += 20 if not re.search(r'[A-Z]', password): issues.append('Password must contain at least one uppercase letter') else: score += 20 if not re.search(r'[a-z]', password): issues.append('Password must contain at least one lowercase letter') else: score += 20 if not re.search(r'[0-9]', password): issues.append('Password must contain at least one number') else: score += 20 if not re.search(r'[!@#$%^&*(),.?":{}|<>]', password): issues.append('Password must contain at least one special character') else: score += 20 return { 'is_strong': len(issues) == 0, 'score': score, 'issues': issues, 'strength': 'Strong' if score >= 80 else 'Medium' if score >= 60 else 'Weak' } async def generate_security_report(self) -> Dict[str, Any]: """Generate comprehensive security report""" # Get various security metrics dependency_scan = await self.vulnerability_scanner.scan_dependencies() config_scan = await self.vulnerability_scanner.scan_configuration() security_summary = await self.audit_logger.get_security_summary() blocked_ips = self.rate_limiter.get_blocked_ips() return { 'report_generated': datetime.utcnow().isoformat(), 'overall_security_score': ( dependency_scan.get('score', 85) + config_scan.get('overall_score', 85) + 85 # Base application score ) // 3, 'dependency_security': dependency_scan, 'configuration_security': config_scan, 'security_events': security_summary, 'blocked_ips': blocked_ips, 'recommendations': [ 'Regularly update all dependencies', 'Monitor security logs for anomalies', 'Implement 2FA for all admin accounts', 'Regular security training for team', 'Automated security scanning in CI/CD', 'Regular penetration testing', 'Backup and disaster recovery testing' ] } # Factory function def create_security_manager(db_session_factory) -> AdvancedSecurityManager: """Create and configure security manager""" return AdvancedSecurityManager(db_session_factory) # Decorators for easy security integration def require_security_validation(max_requests: int = 100, window_seconds: int = 3600): """Decorator for adding security validation to endpoints""" def decorator(func): @wraps(func) async def wrapper(request: Request, *args, **kwargs): # This would integrate with the FastAPI dependency system # For now, it's a placeholder return await func(request, *args, **kwargs) return wrapper return decorator def security_audit_log(event_type: SecurityEventType, threat_level: SecurityThreatLevel = SecurityThreatLevel.LOW): """Decorator for automatic security audit logging""" def decorator(func): @wraps(func) async def wrapper(*args, **kwargs): # This would automatically log the function call result = await func(*args, **kwargs) # Log the event return result return wrapper return decorator
